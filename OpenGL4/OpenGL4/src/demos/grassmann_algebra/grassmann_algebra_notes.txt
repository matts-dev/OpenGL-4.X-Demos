the video teaching all of this stuff
	https://youtu.be/WZApQkDBr5o?list=PLMRtSei06iNK6B9D-Pjtvyp2lyzOCDLCz

historical math:
	quaternions			- hamilton 1843
	exterior algebra	- Grassmann 1844	(theory of extension)
	clifford algebra	- clifford 1878

	Clifford Algebra = Quaternion Algebra + Grassman Algebra (there may be more components to clifford algebra)
		Geometric Algebra is a special case of Clifford Algebra
		Spacetime Algebra is a special case of Clifford Algebra
		
The Wedge Product
	a ^ b
	a wedge b
	AKA
		progressive product (grassmann's term)
		exterior product (other people's term)
	operands
		scalars, vectors, bivectors, trivectors, etc
				s = scalar
				t = scalar
				v = vector
			rules:
				s ^ t == t ^ s == s*t	//scalars just multiply
				s ^ v == v ^ s == s*v	//scalars just scale a vector
				v ^ v == 0				//a vector wedge product with itself is always 0
					wedging a vector with itself equaling zero means the wedge product is anticommunative, ie you can't swap the order (like cross product)
					proof
						wedge two vectors added to each other
							(a+b)^(a+b)				== 0
							a^a + a^b + b^a + b^b	== 0
							a^b + b^a				== 0
												a^b == -b^a
						VIDEO NOTE: if we start from saying we want this behavior, things make more sense -- we want the order to give us different directions for things like quat rotations, normal checking, etc.
					this simple rule of wedging with self is zero, let's us derive the dot and cross product
					the dot and cross product just fall out from having this rule
	bivectors
		bivector = vector ^ vector 
		- bivector is two directions and a magnitude
		- bivectors are distinct from scalars and vectors, they are a new entity
		- represents a 2D area 
			-(an oriented area)
			NOTE:
				vectors
					- oriented 1D direction
				scalars
					-zero dimensional values
		- order of multiplication matters, because the wedge product is anticommunitive (can't swap order)
			first_v ^ second_v = -second_v ^ first_v
	bivectors in 3d
		start with 3 basis vectors, (ortho normal basis vectors)
			e1, e2, and e3
		a 3d vector is then
			a1*e1 + a2*e2 + a3*e3

		notice what happens to basis vectors
			------NOTE when making a video, rederive this before making video so it is fresh, also check for a later note so we don't have to do more steps than necessary, but maybe we should leave that in ---
			------VIDEO MAKING NOTE: can we use x, y, and z basis vectors to make this simpler to explain? note, this make the e23, e31, e12 notation harder, maybe basis_xy, basis_yz, basis_zx, or just xy, yz, zx? ---------
			a^b == (a1*e1 + a2*e2 + a3*e3) ^ (b1*e1 + b2*e2 + b3*e3)
			//distribute the wedge product
			a^b ==	  a1*e1 ^ b1*e1		
					+ a1*e1 ^ b2*e2 
					+ a1*e1 ^ b3*e3
					+ a2*e2 ^ b1*e1
					+ a2*e2 ^ b2*e2
					+ a2*e2 ^ b3*e3
					+ a3*e3 ^ b1*e1
					+ a3*e3 ^ b2*e2
					+ a3*e3 ^ b3*e3
			//rearrange to see what vectors are being wedged together
			a^b ==	  a1*b1 * e1 ^ e1	//wedge with self is 0
					+ a1*b2 * e1 ^ e2 
					+ a1*b3 * e1 ^ e3
					+ a2*b1 * e2 ^ e1
					+ a2*b2 * e2 ^ e2	//wedge with self is 0
					+ a2*b3 * e2 ^ e3
					+ a3*b1 * e3 ^ e1
					+ a3*b2 * e3 ^ e2
					+ a3*b3 * e3 ^ e3	//wedge with self is 0
			//remove the zeros
			a^b ==
					+ a1*b2 * e1 ^ e2 
					+ a1*b3 * e1 ^ e3
					+ a2*b1 * e2 ^ e1	// (e2 ^ e1 == -e1 ^ e2)
					+ a2*b3 * e2 ^ e3	
					+ a3*b1 * e3 ^ e1	// (e3 ^ e1 == -e1 ^ e3)
					+ a3*b2 * e3 ^ e2   // (e3 ^ e2 == -e2 ^ e3)
			//convert these to be their negative flipped counterparts
			a^b ==	///----NOTE:: WHEN MAKING VIDEO, CONSIDER NOT FLIPPING e3^e1, as that is a better one to use for later! It wraps around to e1 and we have to correct that at the end
					+ a1*b2 * e1 ^ e2 
					+ a1*b3 * e1 ^ e3
					+ -a2*b1 * e1 ^ e2		// (e2 ^ e1 == -e1 ^ e2)
					+ a2*b3 * e2 ^ e3	
					+ -a3*b1 * e1 ^ e3		// (e3 ^ e1 == -e1 ^ e3)
					+ -a3*b2 * e2 ^ e3		// (e3 ^ e2 == -e2 ^ e3)
			//group these together
			a^b ==
					+ a1*b2 * e1 ^ e2 
					+ -a2*b1 * e1 ^ e2	
					+ a1*b3 * e1 ^ e3
					+ -a3*b1 * e1 ^ e3	
					+ a2*b3 * e2 ^ e3	
					+ -a3*b2 * e2 ^ e3  
			//arrange on the same line for clairty
			a^b ==
					+ a1*b2 * e1 ^ e2 - a2*b1 * e1 ^ e2	
					+ a1*b3 * e1 ^ e3 - a3*b1 * e1 ^ e3	
					+ a2*b3 * e2 ^ e3 - a3*b2 * e2 ^ e3  
			//factor out the coefficients, to make this a bit more readable
			a^b ==
					+ (a1*b2 - a2*b1) * e1 ^ e2	
					+ (a1*b3 - a3*b1) * e1 ^ e3	
					+ (a2*b3 - a3*b2) * e2 ^ e3  
			//let's rearrange the e1^e3, so it it wraps around, and is e3^e1, but this requires multiplying by a negative 1
			a^b ==
					+ (a1*b2 - a2*b1) * e1 ^ e2	
					+ (a1*b3 - a3*b1) * -1*e3 ^ e1	
					+ (a2*b3 - a3*b2) * e2 ^ e3  
			//distribute the negative 1
			a^b ==
					+ (a1*b2  - a2*b1) * e1 ^ e2	
					+ (-a1*b3 + a3*b1) * e3 ^ e1	
					+ (a2*b3  - a3*b2) * e2 ^ e3  
			//organize so it reads e1, e2, then e3
			a^b ==
					+ (a1*b2  + -a2*b1) * e1 ^ e2	
					+ (a2*b3  + -a3*b2) * e2 ^ e3  
					+ (-a1*b3 + a3*b1) * e3 ^ e1	
			//rearrange the terms so we order them by which basis vector is missing
			a^b ==
					+ (a2*b3  + -a3*b2) * e2 ^ e3	//e1 is missing
					+ (-a1*b3 + a3*b1) * e3 ^ e1	//e2 is missing
					+ (a1*b2  + -a2*b1) * e1 ^ e2	//e3 is missing
			//the coefficients are the values we use in the cross product!
			//but we're expressing it on the "bivector basis" not on the "e1, e2, e3 basis"
			//shorthand notation can be used , e2^e3==e23
			a^b ==
					+ (a2*b3  + -a3*b2) * e2 ^ e3	
					+ (a3*b1  - a1*b3 ) * e3 ^ e1	//rearranged addition to make more sense
					+ (a1*b2  + -a2*b1) * e1 ^ e2	
		Cross Product VS Wedge Product
			--WEDGE PRODUCT IS NOT EXACTLY THE CROSS PRODUCT--
			Cross Product
				Cross product is not associative, 
					((a x b) x c) != (a x (b x c))
				-only 3d (well, kinda -- personally seen people make 2d crossproducts...)
				-an "abuse" of the wedge product; does not convey what is happening behind the scenes
			Wedge Product
				Wedge product is associative
					(a ^ b) ^ c == a ^ (b ^ c)
					(this example creates a trivector)
				Wedge product is defined in -ALL- dimensions

	trivectors
		a ^ b ^ c
		properites
			-multiply 3 things together to get a trivector
			-distinct from scalars, vectors, bivectors
			-represents 3d ORIENTED volume
		a ^ b ^ c
			-you can wedge a bivector with a vector and get a trivector
			-you can wedge 3 vectors to get a trivector
		-in 3D a trivector only has 1 basis vectors
			a ^ b ^ c = (a1b2c3 + a2b3c1 + a3b1c2 - a1b3c2 - a2b1c3 -a3b2c1) * (e1^e2^e3)
-------------------------------------------------
				--- TODO do the algebra to proove these cancelations ---
-------------------------------------------------
			the magnitude is det([a b c])
		-why is there only 1 basis vector in 3d?
			"there's only 1 way we can choose 3 vectors out of a set of 3 vectors"
				-not sure what this means... (x,y,z)(z,x,y) are two ways... guess not?
				-i guess it means, if we try to combine 3 vectors, and only have 3 vectors, then we have to use all our vectors to make a combination
		-trivector looks like a regular scalar
		-trivector aka "pseudoscalar" or "antiscalar"
		-trivector's sign flips under reflection
			-trivectors behave slightly differently than a scalar, because of this reflection sign flip
		scalar triple product
			scalar triple product (a x b) dot c 
			scalar triple product gives same magnitude as trivector (a ^ b ^ c)
				-but the trivector extends into higher dimensions
					-but don't get a scalar in higher dimensions, we have to keep wedging things together to get a scalar
	grading
		grade - the number of things wedged together
			scalars have grade 0
			vectors have grade 1
			bivectors have grade 2
			trivectors have grade 3

	3d multivector algebra 
		the players:
			1 scalar elements
			3 vector elements
			3 bivector elements
			1 trivector elements
		8 total mutlivector basis elements
		no higher grade elements in 3d, because we have no other basis vectors to wedge together

	multivectors in general dimension
		-in n dimensions, number of basis k vector elements is (k here is like number of bivectors, number of trivectors)
			n choose k (n!)/(k!*(n-k)!)
				how many bivectors? n = 3, k = 2
					(3 choose 2) == (3! / 2!*1! == (3*2*1)/(2*1) == 3 
					(xy, yz, zx)
				how many trivectors? n = 3, k = 3
					(3 choose 3) == (3! / 3!*0!) == (3*2*1)/(3*2*1)(1) == 1
					(xyz)
				how many vectors? n=3, k=1
					(3 choose 1) == (3!/ (1!*2!)) == (3*2*1)/(1*2*1) == 3 
					(x,y,z)
		-produces a nice symmetry
		-total number of basis elements is always 2^n
		Dimension		Grade Elements
			1				1 1				//scalar antiscalar?
			2				1 2 1			//scalar, vector, antiscalar
			3				1 3 3 1			//1scalar, 3vectors, 3bivectors, 1trivector
			4				1 4 6 4 1		//1scalar 4vectors, 6bivectors, 4trivectors, 1quadvector
			5				1 5 10 10 5 1	//1 scalar, 5vectors, 10bivectors, 10trivectors, 5quadvectors, 1pent?vector
	4 dimensions
		basis vectors: e1,e2,e3,e4
		basis bivectors (4 choose 2) = 6; {xy,xz,xw, yz, yw, zw}
		basis trivectors (4 choose 3) = 4; {xyz, xyw, xzw, yzw}

	confusion between vector and bivector
		in 3d....
			vectors have 3 components
			bivectors have 3 components
			...so vectors and bivectors look like the same thing
				hence, why knowledge of the difference is not widespread
		physicist noticed there was something different about the result of a crossproduct.
			-cross product produced a different kind of vector
			-cross product result transforms differently than a regular vector
				-so physicist called xproduct result a "axial vector, pseudovetor, covector, covariant vector"
				-physicist called regular vectors "polar vectors" or "contravariant vectors"
			simple example
				what happens to cross product result when you hit it with a simple reflection matrix (where 1 colum, say first, has a negated value)
					M =(imagine identity matrix, where first column has -1 instead of 1; this is a relfection on x)
					M = (-1,0,0)
						( 0,1,0)
						( 0,0,1)
					(1,0,0) cross (0,1,0)		= (0,0, 1)					//crossing x axis with y axis, we get the z axis as a result
					M*(1,0,0) cross M*(0,1,0)	= (0,0,-1)					//transform x&y axis by matrix that flips x, we get a flipped z
						not same as M*(0,0,1)	= (0,0, 1)					//if we just transform z axis by the same matrix (flipped x) we do not get the same result as above
				So, if you transform the crossproduct-input vectors before hand, you don't get the same result as transforming the crossproduct result.
					M(a1*e1 + a2*e2 +a3*e3) = a1*M1 + a2*M2 +a3*M3			//because the e1,e2,and e3 are the unit basis vectors, so like multipliying by 1. ; or just expand and do the multiplication
					Apply M transform before cross producting two vectors 	//(this shows us what should be how to calculate the correct answer)
						Ma cross Mb =
							(a1*M1 + a2*M2 + a3*M3) cross (b1*M1 + b2*M2 + b3*M3)	//by rule M(a1*e1 + a2*e2 +a3*e3) = a1*M1 + a2*M2 +a3*M3
					Distribute cross product
						Ma cross Mb =
								a1*M1 cross b1*M1  		//M1 cross M1 == 0
								+ a1*M1 cross b2*M2
								+ a1*M1 cross b3*M3
								+ a2*M2 cross b1*M1
								+ a2*M2 cross b2*M2 	//M2 cross M2 == 0
								+ a2*M2 cross b3*M3
								+ a3*M3 cross b1*M1
								+ a3*M3 cross b2*M2
								+ a3*M3 cross b3*M3		//M3 cross M3 == 0
					Removed the cross products that zero out
						Ma cross Mb =
								+ a1*M1 cross b2*M2		
								+ a1*M1 cross b3*M3
								+ a2*M2 cross b1*M1		// M2 cross M1 == -M1 cross M2;  reorganize so it goes subscript counts up
								+ a2*M2 cross b3*M3
								+ a3*M3 cross b1*M1		// M3 cross M1 == -M1 cross M3;	NOTE: you can convince yourself of this by pretending M1=x, M2=y, M3=z and doing right hand rule 	VIDEO NOTE: it is better to do M3 to M1,
								+ a3*M3 cross b2*M2		// M3 cross M2 == -M2 cross M3
					Convert the cross products to like terms (comments above)
						Ma cross Mb =
								+ a1*M1 cross b2*M2	+ (-b1*M1 cross a2*M2)		
								+ a1*M1 cross b3*M3	+ (-b1*M1 cross a3*M3)
								+ a2*M2 cross b3*M3 + (-b2*M2 cross a3*M3)
					Factor out coefficients (VIDEO: SANITY CHECK -- IS THIS A LEGAL OPERATION?)
						Ma cross Mb =
								+ a1*b2(M1 cross M2) + -b1*a2(M1 cross M2)		
								+ a1*b3(M1 cross M3) + -b1*a3(M1 cross M3)
								+ a2*b3(M2 cross M3) + -b2*a3(M2 cross M3)
					Group coefficents
						Ma cross Mb =
								+ (a1*b2 -b1*a2)(M1 cross M2)
								+ (a1*b3 -b1*a3)(M1 cross M3) 	//(M1 cross M3) == (-M3 cross M1)
								+ (a2*b3 -b2*a3)(M2 cross M3)
					Convert M1 cross M3 to M3 cross M1 to do cyclic nature of basis vectors
						Ma cross Mb =
								+ (a1*b2 -b1*a2)(M1 cross M2)
								+ (a1*b3 -b1*a3)(-M3 cross M1)	//distribute -1
								+ (a2*b3 -b2*a3)(M2 cross M3)
					Distribute -1
						Ma cross Mb =
								+ (a1*b2 -b1*a2)(M1 cross M2)
								+ (-a1*b3 +b1*a3)(M3 cross M1)
								+ (a2*b3 -b2*a3)(M2 cross M3)
					Reorganize ordering of M2, M3, and M1 to match video
						Ma cross Mb =
								+ (a2*b3 -b2*a3)(M2 cross M3)
								+ (-a1*b3 +b1*a3)(M3 cross M1)
								+ (a1*b2 -b1*a2)(M1 cross M2)
					Flip -a1*b3 +b1*a3 to b1*a3 -a1*b3 
						Ma cross Mb =
								+ (a2*b3 -b2*a3)(M2 cross M3)
								+ (b1*a3 -a1*b3)(M3 cross M1)
								+ (a1*b2 -b1*a2)(M1 cross M2)
					Make it so that `a` always comes before `b` in coefficients
						Ma cross Mb =
								+ (a2*b3 -a3*b2)(M2 X M3)
								+ (a3*b1 -a1*b3)(M3 X M1)
								+ (a1*b2 -a2*b1)(M1 X M2)
				So, if we take these basis vectors, and dot it with the one we're missing. We end up with the determinant of M
					-this is doing the scalar triple product, which gives the determinent of a matrix
						(M2 cross M3) dot (M1)	= Det(M)
						(M3 cross M1) dot (M2)	= Det(M) 
						(M1 cross M2) dot (M3)	= Det(M)
				If we write this in matrix form, we will get a an identity matrix that has been multiplied by determinant of M
					Below is doing the scalar triple product above, but using matrix machinery to do it
					cross products are rows
					the reason for 0s in the matrix can be seen from circular shift property of scalar triple product:((M2 cross M3) dot M3) == ((M3 cross M3) dot M2), ALT EXAMPLE: ((M2 X M3) dot M2 == M3 dot (M2 X M2)
						|M2 X M3|  	|M1x M2x M3x|	|det(M)	0			0 |
						|M3 X M1| * |M1y M2y M3y| = |0		det(M)		0 |
						|M1 X M2|	|M1z M2z M3z|	|0		0		det(M)|
					looking at this in a more collapsed form, ask yourself what must the left hand side be? ie what must is the thing we're multiplying by M be?
							|M2 X M3|  	     |det(M)	0			0 |
							|M3 X M1| * M  = |0			det(M)		0 |
							|M1 X M2|		 |0			0		det(M)|
						Well, the RESULT looks like an idenity matrix scaled by the determinant.
							det(M)*I
						Identity matrix is achieved when we do  (M-1 is inverse)
							(M-1)*M
						so this must be true
							|M2 X M3|  	
							|M3 X M1|  == det(M)*(M-1)
							|M1 X M2|		
						for us to get
							det(M)(M-1)*(M) == diagonal_matrix(det(M))					
				THEREFORE
					all of this work tells us this:
						-the correct matrix to multiply to transform result of cross product (eg transforming normals) 	`det(m)transpose(M-1)` for column matrices
						-after transposing to math works out, we get det(M)*tranpose(M-1) as the transform matrix.
					why?
						(I) we solved what `Ma cross Mb` was equal to
							Ma X Mb =	+ (a2*b3 -a3*b2)(M2 X M3)
										+ (a3*b1 -a1*b3)(M3 X M1)
										+ (a1*b2 -a2*b1)(M1 X M2)
						(II) We found that this was true
							|M2 X M3|  	
							|M3 X M1|  == det(M)*(M-1)
							|M1 X M2|		
						(III) We can view (I) as matrix * vector multiplication (vector is the operand with a,b coefficients
							-note: it helps to use subsitution to prove this out
																				column mat    column vec
								Ma X Mb =	+ (a2*b3 -a3*b2)(M2 X M3)		=	|M2, M3, M1|  |a2*b3 -a3*b2|	
											+ (a3*b1 -a1*b3)(M3 X M1)			|x	 x    x| *|a3*b1 -a1*b3|	
											+ (a1*b2 -a2*b1)(M1 X M2)			|M3  M1  M2|  |a1*b2 -a2*b1|	
							substitution helps us see this is true
								Ma X Mb = 	|M23x,R31x, O12x|  |q|		|q*m23x + p*r31x, s*O12x|
											|M23y,R31y, O12y| *|p|	=	|q*m23y + p*r31y, s*O12y|
											|M23z,R13z, O12z|  |s|		|q*m23y + p*r31y, s*O12y|
						(IV) because we had to transpose rows to column mat -- for math to work out -- this means we need to transpose our dervied result too
							notice we had to transpose this to make the dot products work out and match what we solved for
								|M2 X M3|  	 |M2, M3, M1|
								|M3 X M1| to |x	 x    x |
								|M1 X M2|	 |M3  M1  M2|	
							so
								det(M)*(M-1) ======> det(m)transpose(M-1)
						(V) we can substitue tranpose(IV) into (III); still matrix * vector multiplication
										column mat					column vec
							Ma X Mb =	det(m)transpose(M-1) 		[a2*b3 -a3*b2,
																*  	 a3*b1 -a1*b3,
														 	 		 a1*b2 -a2*b1]
						(VI) we now know a matrix we can multiply by to transform cross products by that will result correctly. det(M)*trans(inv(m))
					Special Cases
						-when M orthogonal, trans(m-1) == m
							-this means we don't always have to go through all the work in all cases
							-but with non-uniform scales and shears, we need to use this derived matrix we found
						-if det is positive, and you don't care about length, det can be left out from matrix that transforms result of crossproducts
						-det*inverse(transpose) = adjugate tranpose
					Why does cross product require special transform matrix?
						cross product does not produce vector, it produces a bivector
						bivectors don't behave like vectors
							they are on a different basis than vectors
					We are transforming normal vectors in correctly when doing nonuniform scales.
						-normal = cross(triEdge1, triEdge2)
							-this is a bivector
							-we need to transform it like a bivector (the cross product stuff we ust figured out above)
						-we're just getting lucky, because we normalize after and only care that the dot product is still zero
							-non-uniform scales move normals so they are not perpendicular
							-classic knowledg is to use inverse transpose
								derivation (* in this case is dot product)
									0 = N*T
									0 = U*N*M*T					//u is unknown matrix
									0 = trans(N)*trans(U)*M*T	//trans(AB) = trans(B)trans(A) //from linear algebra
										trans(U) = inv(M)		//look, trans(U) must be inverse of M
										U = trans(inv(m))		/solve for U to figure out what we multiply N by
								this misses extra factor of det(M)											
									-doesn't work if reflection or scaling going on
									-really just preserving 0 dot product
	continuing confusion between vector and bivector (25:04)
		reason why vectors and bivectors look the same in 3d (not 4d)
			the 1vectors
				-only use 1 basis vectorrs
				-have 3 components
			the (n-1) vectors
				-use all but 1 basis vector
				-have 3 components in 3d
			ANTIVECTOR
				the 1vectors and (n-1)vectors are complementary
					-hence the name "antivector" for (n-1)vectors
		convention for writing bars on basis vector, eg _e1 is everything except e1.
			(not from the book, a bar above means the right complement, for me e1_ = right complement(top bar), _e1 = left complement(bottom bar))
			-from the book, you can swap positions of wedge but you have to negate, I don't recall if this is true for all grade systems or only odd grade systems (eg 3d or 4d)
				NOTE: this is grade4, even grade
					-wedge always anticommutes (page 139) (anticommute means flip to negative sign when reversing order), this changes when wedging things of different grades (pg145)
					-antiwedge anticommutes on even grades pg:156)
			ei*ei_ = e1^e2^e3^e4  
				e1_ = e2 ^ e3 ^ e4		(e1^e2^e3^e4)
				e2_ = e1 ^ e4 ^ e3		(e2^e1^e4^e3) => (-e1^e2^e4^e3)=>(-e1^e2^-e3^e4)=>(--e1^e2^e3^e4)=>(e1^e2^e3^e4)
				e3_ = e1 ^ e2 ^ e4		(e3^e1^e2^e4) => (-e1^e3^e2^e4)=>(-e1^-e2^e3^e4)=>(--e1^e2^e3^e4)=>(e1^e2^e3^e4)
				e4_ = e1 ^ e3 ^ e2		(e4^e1^e3^e2) => (-e1^e4^e3^e2)=>(-e1^e4^-e2^e3)=>(-e1^-e2^-e4^e3)=>(-e1^-e2^--e3^e4)=>(----e1^e2^e3^e4)=>(e1^e2^e3^e4)
					VIDEO NOTE: it is important to clarify that these swapping rules are from the antiassociativity rule
						-todo: is it trivial to show that?
						-todo: is it true for 4d in addition 3d, or is it a case of odd grade behaves differently?
	Vector Antivector Product (THE ORIGIN OF THE DOT PRODUCT)
		-VIDEO NOTE: this would probably be a cool hook, the dot product is the result of a "multiplication-like" operation between a vector and an antivector
		vector^antivector 
			3d = vector^bivector
			4d = vector^trivector (table on page 147 of book)
		dot product coefficient
			-vector ^ antivector == dot product
			-vector antivector complement each other 
			-vector antivector "fill" in the volume element
			-dot product gives a ANTISCALAR/PSEUDOSCALAR
			(a1e1 + a2e2 + a3e3) ^ (b1e1_ + b2e2_ + b3e3_) = (a1b1 + a2b2 +a3b3)(e1^e2^e3)
		deriving the dot product
			//distribute the wedge product 
			(a1e1 + a2e2 + a3e3) ^ (b1e1_ + b2e2_ + b3e3_) =
				+ a1e1 ^ b1e1_
				+ a1e1 ^ b2e2_
				+ a1e1 ^ b3e3_
				+ a2e2 ^ b1e1_
				+ a2e2 ^ b2e2_
				+ a2e2 ^ b3e3_
				+ a3e3 ^ b1e1_
				+ a3e3 ^ b2e2_
				+ a3e3 ^ b3e3_
			//expand the definition of the antivector basis so they're defined in terms of normal basis and not antibasis
			//this is from pg 149, where we show what things like e1_=, e2_= e3_= e4_=
									e1_ = e2^e3 = e23
									e2_ = e3^e1 = e31
									e3_ = e1^e2 = e12
			//note above matches crossproduct intuition of crossing xy=z, yz=x, zx=y
				(a1e1 + a2e2 + a3e3) ^ (b1e1_ + b2e2_ + b3e3_) =
					+ a1e1 ^ b1(e2^e3)
					+ a1e1 ^ b2(e3^e1)
					+ a1e1 ^ b3(e1^e2)
					+ a2e2 ^ b1(e2^e3)
					+ a2e2 ^ b2(e3^e1)
					+ a2e2 ^ b3(e1^e2)
					+ a3e3 ^ b1(e2^e3)
					+ a3e3 ^ b2(e3^e1)
					+ a3e3 ^ b3(e1^e2)
			//distribute coefficients to front
				(a1e1 + a2e2 + a3e3) ^ (b1e1_ + b2e2_ + b3e3_) =
					+ a1b1(e1^e2^e3)	
					+ a1b2(e1^e3^e1)	//e1^e1==0 (can swap_negate to get here, (e1^e3^e1)=>(-e3^e1^e1)
					+ a1b3(e1^e1^e2)	//e1^e1==0
					+ a2b1(e2^e2^e3)	//e2^e2==0
					+ a2b2(e2^e3^e1)
					+ a2b3(e2^e1^e2)	//e2^e2==0
					+ a3b1(e3^e2^e3)	//e3^e3==0
					+ a3b2(e3^e3^e1)	//e3^e3==0
					+ a3b3(e3^e1^e2)
			//remove zeros
				(a1e1 + a2e2 + a3e3) ^ (b1e1_ + b2e2_ + b3e3_) =
					+ a1b1(e1^e2^e3)	
					+ a2b2(e2^e3^e1)	//(e2^e3^e1)=>(e2^-e1^e3)=>(--e1^e2^e3)=>(e1^e2^e3)	
					+ a3b3(e3^e1^e2)	//(e3^e1^e2)=>(-e1^e3^e2)=>(--e1^e2^e3)=>(e1^e2^e3)	
			//rearrnage terms so wedges all look teh same (see comments above)
				(a1e1 + a2e2 + a3e3) ^ (b1e1_ + b2e2_ + b3e3_) =
					+ a1b1(e1^e2^e3)	
					+ a2b2(e1^e2^e3)
					+ a3b3(e1^e2^e3)
		dot product viewed as vector^antivector	
			N dot L
				N is an antivector (created from crossing two vectors?)
				L is a vector
				calculates volume of extruded bivector
					-we multipling a plane-like (bivector/antivector) by a vector direction, making a volume
				-this gives us an antiscalar result
					-this means proper way to transform it is slightly different
					-normals transform with det(M)(transpose(M-1)) (see cross product work above to refresh this)
						(detM)M**(-t)N dot ML
						N**(T)(detM)M^(-1) ML			//flip N and M, N now row vector, but have to flip M(-T) for result to be same
						(detM)N dotL					//cancel out M(-1)*M

The Antiwedge product (regressive product) (v)
	- AKA regressive product
	- symmetric to wedge product
	- operates on antivectors (similar to how wedge operates on vectors)
		- antiwedge product -takes antivectors to produce smaller things	
			-decreases grade
		- wedge product 	-takes vectors to produce larger things (bivectors, etc)
			-increases grade
	-does things in reverse of the wedge product
	-example notation
		e1_ v e2_
	-same properties as wedge product
	-operates on complementary basis, ie the "antibasis"
		-completmentary space
		-works on e_ instead of e
	-reduces grade
		example:
			A = grade r
			B = grade s
			A^B = grade r + s
			AvB = grade n - (n-r) - (n-s) == grade (r+s-n) //distribute negative and cancel terms
		might be useful to think of antivectors as having grade -1
		3d example 1:
			A=grade2 (bivector)
			B=grade2 (bivector)
			AvB = (2+2) - 3 = 1 == regular vector
	-thinking about antiwedge
			e1_ v e2_ = e3
			e2_ v e3_ = e1
			e3_ v e1_ = e2
		-this is similar to how we can do `e1^e2=e3_`
		-I think it is better to think about them like wedge, 
			"what is the group of antibasis we have antiwedged together"
			shorthand notation
				e12_ = e1_ v e2_
				e23_ = e2_ v e3_
				e31_ = e3_ v e1_
				e123_ = e1_ v e2_ v e3_
		-but you can think about this in the normal basis too
				e1_ v e2_ = (e2 ^ e3) v (e3 ^ e1) = e3
				e2_ v e3_ = (e3 ^ e1) v (e1 ^ e2) = e1
				e3_ v e1_ = (e1 ^ e2) v (e2 ^ e3) = e2
			-above, can be said:
				"antiwedge keeps only what is in both antivectors"
					-perhaps this isn't quite right, but that is what I see above
					-notice the same basis vectors are close to the 'v' operator. 
			----------------------------
					TODO
					-i'm not sure if they need to straddle this ????? 
			----------------------------
	JOIN AND MEET
		join operation
			-wedge product joins vectors together
			-analogous to union
		meet operation
			-antiwege product "joins" antivectors
			-antivectors represent ABSENCE of geometry
			-joining antivectors is like removing vectors (antivectors are like, all the vectors nto included)
			-analogous to intersection
			-called "meet" operation specifically
		wedge product builds things up, 
			-you get things that span more dimensions
		antiwedge works like intersections
			-you take big things like planes or volumes,
			-you antiwedge them together to get smaller things
				-where those things intersect

Homogenous Coordinates
	-4 dimension
	-point = (x,y,z,w)	
	-allows affine transformations through a 4x4 matrix (ie the translation down side, rotation/scale in middle)
	-Homogenous used throught computer graphics
	-projection matrices used homogenous coordinates very heavily

Homogenous Points
	point_4d = (x,y,z,w)
	point_3d = (x,y,z) / w
		-this projects 4d vector onto 3d subspace where w = 1
			(intersection of 4d vector with the plane where w = 1)

Homogenous Model
	grassman algebra extends homogenous model to included
		3d Points
		3d lines
		3d planes
	wedge and antiwedge products perform union and intersection opertions among all of these
		eg (examples not from video but from memory, verify later)
			?point wedge point = line
			?point wedge point wdge point = plane
			?plane antiwedge plane = line intersection
	
4D Grassman Algebra Review
	components 
		1 scalar unit		
		4 vectors			e1, e2, e3, e4
		6 biveectors 		e12, e23, e31, e41, e42, e43
		4 antivectors 		e1_, e2_, e3_, e4_
		1 antiscalar		

Homogeneous Lines
	-take wedge product of two lines
	two point example			(w set to 1 to simplify)
		P = (Px, Py, Pz, 1) 	= PxE1 + PyE2 + PzE3 + E4
		Q = (Qx, Qy, Qz, 1) 	= QxE1 + QyE2 + QzE3 + E4

	P wedge Q = 
		+(Qx - Px)* e41
		+(Qy - Py)* e42
		+(Qz - Pz)* e43
		+(PyQz - PzQy)* e23
		+(PzQx - PxQz)* e31
		+(PxQy - PyQx)* e12
	w=1 derivation
		P ^ Q = (PxE1 + PyE2 + PzE3 + E4) ^	(QxE1 + QyE2 + QzE3 + E4)
		P ^ Q =
			+ PxE1 ^ QxE1
			+ PxE1 ^ QyE2
			+ PxE1 ^ QzE3
			+ PxE1 ^ E4

			+ PyE2 ^ QxE1
			+ PyE2 ^ QyE2
			+ PyE2 ^ QzE3
			+ PyE2 ^ E4

			+ PzE3 ^ QxE1
			+ PzE3 ^ QyE2
			+ PzE3 ^ QzE3
			+ PzE3 ^ E4

			+ E4 ^ QxE1
			+ E4 ^ QyE2
			+ E4 ^ QzE3
			+ E4 ^ E4
		//cancel out self cancelations (E1^E1 = 0)
		P ^ Q =
			+ PxE1 ^ QxE1 //0
			+ PxE1 ^ QyE2
			+ PxE1 ^ QzE3
			+ PxE1 ^ E4

			+ PyE2 ^ QxE1
			+ PyE2 ^ QyE2 //0
			+ PyE2 ^ QzE3
			+ PyE2 ^ E4

			+ PzE3 ^ QxE1
			+ PzE3 ^ QyE2
			+ PzE3 ^ QzE3 //0
			+ PzE3 ^ E4

			+ E4 ^ QxE1
			+ E4 ^ QyE2
			+ E4 ^ QzE3
			+ E4 ^ E4	//0
		// group basis
		P ^ Q =
			+ PxE1 ^ QyE2		
			+ PxE1 ^ QzE3		
			+ PxE1 ^ E4

			+ PyE2 ^ QxE1	
			+ PyE2 ^ QzE3
			+ PyE2 ^ E4

			+ PzE3 ^ QxE1
			+ PzE3 ^ QyE2
			+ PzE3 ^ E4

			+ E4 ^ QxE1
			+ E4 ^ QyE2
			+ E4 ^ QzE3
		//reorganize orders of e1e2 to reduce pairings
		P ^ Q =
			+ PxQy 	E12		
			+ PxQz 	E13		//flip for xproduct portion of line
			+ Px 	E14		//flip for vector

			+ PyQx 	E21		//flip for xproduct portion of line
			+ PyQz 	E23		
			+ Py 	E24		//flip for vector

			+ PzQx 	E31
			+ PzQy 	E32		//flip for xproduct portion of line
			+ Pz   	E34		//flip for vector

			+ Qx E41
			+ Qy E42
			+ Qz E43
		//start flipping ordering (which requires negating) so that we end up with an ordering similar to the insightful ending
		P ^ Q =
			+ PxQy 	E12		
			- PxQz 	E31		
			- Px 	E41

			- PyQx 	E12	
			+ PyQz 	E23
			- Py 	E42

			+ PzQx 	E31
			- PzQy 	E23
			- Pz   	E43

			+ Qx E41
			+ Qy E42
			+ Qz E43
		//arrange to reveal a vector and a crossproduct
		P ^ Q =
			+ PyQz 	E23
			- PzQy 	E23
			+ PzQx 	E31
			- PxQz 	E31
			+ PxQy 	E12		
			- PyQx 	E12	
			+ Qx 	E41
			- Px 	E41
			+ Qy 	E42
			- Py 	E42
			+ Qz	E43
			- Pz   	E43

		//group into the line
			P ^ Q =
			+ (PyQz- PzQy) E23
			+ (PzQx -PxQz) E31
			+ (PxQy -PyQx) E12		

			+ (Qx -Px) 	E41
			+ (Qy -Py) 	E42
			+ (Qz -Pz)	E43

	Derive without W=1, but then substitute in W=1
		P ^ Q = (PxE1 + PyE2 + PzE3 + PwE4) ^ (QxE1 + QyE2 + QzE3 + QwE4)
		//clear out zero multiplies
		P ^ Q =
			+ PxE1 ^ QxE1		//e1^e1 == 0
			+ PxE1 ^ QyE2
			+ PxE1 ^ QzE3
			+ PxE1 ^ QwE4

			+ PyE2 ^ QxE1
			+ PyE2 ^ QyE2		//e2^e2 == 0
			+ PyE2 ^ QzE3
			+ PyE2 ^ QwE4

			+ PzE3 ^ QxE1
			+ PzE3 ^ QyE2
			+ PzE3 ^ QzE3		//e3^e3 == 0
			+ PzE3 ^ QwE4

			+ PwE4 ^ QxE1
			+ PwE4 ^ QyE2
			+ PwE4 ^ QzE3
			+ PwE4 ^ QwE4		//e4^e4==0
		//factor out scalars from wedge prodcuts
		P ^ Q =
			+ PxQy E1^E2
			+ PxQz E1^E3
			+ PxQw E1^E4

			+ PyQx E2^E1
			+ PyQz E2^E3
			+ PyQw E2^E4

			+ PzQx E3^E1
			+ PzQy E3^E2
			+ PzQw E3^E4

			+ PwQx E4^E1
			+ PwQy E4^E2
			+ PwQz E4^E3
		// start flipping things around so we can get a cross product (M) and a vector (T) when W = 1 (see ending result when W=1 to see which E12 orderings are conventient)
		P ^ Q =
			+ PxQy E1^E2
			+ PxQz E1^E3	//flip M
			+ PxQw E1^E4	//flip for T

			+ PyQx E2^E1	//flip M
			+ PyQz E2^E3
			+ PyQw E2^E4	//flip for T

			+ PzQx E3^E1
			+ PzQy E3^E2	//flip M
			+ PzQw E3^E4	//flip for T
			
			+ PwQx E4^E1
			+ PwQy E4^E2
			+ PwQz E4^E3 
		P ^ Q =
			+ PxQy E12
			- PxQz E31	
			- PxQw E41	

			- PyQx E12	
			+ PyQz E23
			- PyQw E42	

			+ PzQx E31
			- PzQy E23	
			- PzQw E43	

			+ PwQx E41
			+ PwQy E42
			+ PwQz E43 
		// pair up related basis
		P ^ Q =
			+ PxQy E12
			- PyQx E12	

			+ PwQx E41
			- PxQw E41	

			+ PyQz E23
			- PzQy E23	

			+ PwQy E42
			- PyQw E42	

			+ PzQx E31
			- PxQz E31	

			+ PwQz E43 
			- PzQw E43	
		//factor out coeffiecients
		P ^ Q =
			+ (PxQy - PyQx) E12	
			+ (PwQx - PxQw) E41	
			+ (PyQz - PzQy) E23	
			+ (PwQy - PyQw) E42	
			+ (PzQx - PxQz) E31	
			+ (PwQz - PzQw) E43	
		//group based on T and M
		P ^ Q =
			+ (PwQx - PxQw) E41	//T
			+ (PwQy - PyQw) E42	//T
			+ (PwQz - PzQw) E43	//T

			+ (PyQz - PzQy) E23	 //M
			+ (PzQx - PxQz) E31	 //M
			+ (PxQy - PyQx) E12	 //M
			//group based on T and M
		//substitute 1 into W; ie any coefficient with a Pw or Qw
		P ^ Q =
			+ (Qx - Px) E41	//T
			+ (Qy - Py) E42	//T
			+ (Qz - Pz) E43	//T

			+ (PyQz - PzQy) E23	 //M
			+ (PzQx - PxQz) E31	 //M
			+ (PxQy - PyQx) E12	 //M

	this bivector spans 2d plane in 4d
	in subspace w=1, this is a 3d line (plane intersecting another plane gives a line between them)

	decomposed into two products 
	P wedge Q = 
		+(Qx - Px)* e41  +(Qy - Py)* e42  +(Qz - Pz)* e43					// T = tangent vector; 		difference between 3d points q and p (ie a vector along the line between them);
		+(PyQz - PzQy)* e23  +(PzQx - PxQz)* e31 +(PxQy - PyQx)* e12		// M = moment bivector;		cross product between p and q

	no longer information about the points used to create the the line
		note: the parameteric representation of a line (line= origin + direction*t) does have this informaiton

	Moment is perpendicular to the tangent at all times
		moment represents winding of tangent around the origin (image of a circular disk where T is spinning around M)

Plucker Coordinates
	L = {Q-P : PXQ} 	=== A line in plucker coordinates
		the M and T of 3d lines created from point wedge point are the origin of plucker coordinates
		the (plucker) coordinates are the coefficients of a 4D bivector (ie the result of a wedge product)
	this demystifies a bunch of seemingly arbitrary formulas in plucker coordinates
		plucker came up with a bunch of ways to combine this line equation to do geometric unions/intersectiosn with 4d-points and 4d-planesvectors

Homogenous Planes
	take wedge product of three 4D points
	three point example			(w set to 1 to simplify)
		P = (Px, Py, Pz, 1) 	= PxE1 + PyE2 + PzE3 + E4
		Q = (Qx, Qy, Qz, 1) 	= QxE1 + QyE2 + QzE3 + E4
		R = (Rx, Ry, Rz, 1) 	= RxE1 + RyE2 + RzE3 + E4
	P^Q^R = Nx*e1_ + Ny*e2_ + Nz*e3_ +D*e4_
		N is the 3d normal bivector
		D is the offset from the origin (in units of N)

		N = (P3d ^ Q3d) + (Q3d ^ R3d) +  (R3d ^ P3d)
		D = - P3D ^ Q3d ^ R3d

	Derivation (with W coordinate)
		//end result
			P^Q^R = Nx*e1_ + Ny*e2_ + Nz*e3_ +D*e4_
		//use previous derivation of P^Q and wedge in R
		P ^ Q =
			+ (PxQy - PyQx) E12	
			+ (PwQx - PxQw) E41	
			+ (PyQz - PzQy) E23	
			+ (PwQy - PyQw) E42	
			+ (PzQx - PxQz) E31	
			+ (PwQz - PzQw) E43	
		//wedge in R
		P ^ Q ^ R =
			(
				+ (PxQy - PyQx) E12	
				+ (PwQx - PxQw) E41	
				+ (PyQz - PzQy) E23	
				+ (PwQy - PyQw) E42	
				+ (PzQx - PxQz) E31	
				+ (PwQz - PzQw) E43	
			) 
			^ (RxE1 + RyE2 + RzE3 + RwE4)
		//distrbute additions
		P ^ Q ^ R =
			+ (PxQy - PyQx) E12	^ RxE1
			+ (PwQx - PxQw) E41	^ RxE1
			+ (PyQz - PzQy) E23	^ RxE1
			+ (PwQy - PyQw) E42	^ RxE1
			+ (PzQx - PxQz) E31	^ RxE1
			+ (PwQz - PzQw) E43	^ RxE1

			+ (PxQy - PyQx) E12	^ RyE2
			+ (PwQx - PxQw) E41	^ RyE2
			+ (PyQz - PzQy) E23	^ RyE2
			+ (PwQy - PyQw) E42	^ RyE2
			+ (PzQx - PxQz) E31	^ RyE2
			+ (PwQz - PzQw) E43	^ RyE2

			+ (PxQy - PyQx) E12	^ RzE3
			+ (PwQx - PxQw) E41	^ RzE3
			+ (PyQz - PzQy) E23	^ RzE3
			+ (PwQy - PyQw) E42	^ RzE3
			+ (PzQx - PxQz) E31	^ RzE3
			+ (PwQz - PzQw) E43	^ RzE3

			+ (PxQy - PyQx) E12	^ RwE4
			+ (PwQx - PxQw) E41	^ RwE4
			+ (PyQz - PzQy) E23	^ RwE4
			+ (PwQy - PyQw) E42	^ RwE4
			+ (PzQx - PxQz) E31	^ RwE4
			+ (PwQz - PzQw) E43	^ RwE4
		//clear out zeros from wedging together same basis vector
		P ^ Q ^ R =
			+ (PxQy - PyQx) E12	^ RxE1	//e1 == 0
			+ (PwQx - PxQw) E41	^ RxE1	//e1 == 0
			+ (PyQz - PzQy) E23	^ RxE1
			+ (PwQy - PyQw) E42	^ RxE1
			+ (PzQx - PxQz) E31	^ RxE1 //e1 == 0
			+ (PwQz - PzQw) E43	^ RxE1 

			+ (PxQy - PyQx) E12	^ RyE2 //e2 == 0
			+ (PwQx - PxQw) E41	^ RyE2 
			+ (PyQz - PzQy) E23	^ RyE2 //e2 == 0
			+ (PwQy - PyQw) E42	^ RyE2 //e2 == 0
			+ (PzQx - PxQz) E31	^ RyE2
			+ (PwQz - PzQw) E43	^ RyE2

			+ (PxQy - PyQx) E12	^ RzE3 
			+ (PwQx - PxQw) E41	^ RzE3
			+ (PyQz - PzQy) E23	^ RzE3 //e3 == 0
			+ (PwQy - PyQw) E42	^ RzE3
			+ (PzQx - PxQz) E31	^ RzE3 //e3 == 0
			+ (PwQz - PzQw) E43	^ RzE3 //e3 == 0

			+ (PxQy - PyQx) E12	^ RwE4
			+ (PwQx - PxQw) E41	^ RwE4 //e4 == 0
			+ (PyQz - PzQy) E23	^ RwE4
			+ (PwQy - PyQw) E42	^ RwE4 //e4 == 0
			+ (PzQx - PxQz) E31	^ RwE4
			+ (PwQz - PzQw) E43	^ RwE4 //e4 == 0
		// just showing after deletins before shifting things around
		P ^ Q ^ R =
			+ (PyQz - PzQy) E23	^ RxE1
			+ (PwQy - PyQw) E42	^ RxE1
			+ (PwQz - PzQw) E43	^ RxE1 

			+ (PwQx - PxQw) E41	^ RyE2 
			+ (PzQx - PxQz) E31	^ RyE2
			+ (PwQz - PzQw) E43	^ RyE2

			+ (PxQy - PyQx) E12	^ RzE3 
			+ (PwQx - PxQw) E41	^ RzE3
			+ (PwQy - PyQw) E42	^ RzE3

			+ (PxQy - PyQx) E12	^ RwE4
			+ (PyQz - PzQy) E23	^ RwE4
			+ (PzQx - PxQz) E31	^ RwE4
		// combine basis and distribute in R terms
		P ^ Q ^ R =
			+ (PyQz - PzQy)*Rx * E231
			+ (PwQy - PyQw)*Rx * E421
			+ (PwQz - PzQw)*Rx * E431 
			+ (PwQx - PxQw)*Ry * E412 
			+ (PzQx - PxQz)*Ry * E312
			+ (PwQz - PzQw)*Ry * E432
			+ (PxQy - PyQx)*Rz * E123 
			+ (PwQx - PxQw)*Rz * E413
			+ (PwQy - PyQw)*Rz * E423
			+ (PxQy - PyQx)*Rw * E124
			+ (PyQz - PzQy)*Rw * E234
			+ (PzQx - PxQz)*Rw * E314
		//Distribute R
		P ^ Q ^ R =
			+ (PyQzRx - PzQyRx) * E231
			+ (PwQyRx - PyQwRx) * E421
			+ (PwQzRx - PzQwRx) * E431 

			+ (PwQxRy - PxQwRy) * E412 
			+ (PzQxRy - PxQzRy) * E312
			+ (PwQzRy - PzQwRy) * E432

			+ (PxQyRz - PyQxRz) * E123 
			+ (PwQxRz - PxQwRz) * E413
			+ (PwQyRz - PyQwRz) * E423

			+ (PxQyRw - PyQxRw) * E124
			+ (PyQzRw - PzQyRw) * E234
			+ (PzQxRw - PxQzRw) * E314
		//The final form looks like this (with the w's set to 1, so slightly different)
		// P^Q^R = Nx*e1_ + Ny*e2_ + Nz*e3_ +D*e4_
		// these are the anti vectors e1_, e2_, e3_, e4_
		// earlier, we were given these orderings to achieve the right complement antivectors
		//	e1_ == e2 ^ e3 ^ e4 == e234
		//	e2_ == e1 ^ e4 ^ e3 == e143
		//	e3_ == e1 ^ e2 ^ e4 == e124
		//	e4_ == e1 ^ e3 ^ e2 == e132
		//
		//arrange these so that they are one of those 4.
		//every shift negates in position
		P ^ Q ^ R =:
			+ (PyQzRx - PzQyRx) * E231			//malformed e4_ goal(e132)	steps(231:->213->123->132)	sign-
			+ (PwQyRx - PyQwRx) * E421  		//malformed e3_ goal(e124)  steps(421:->412->142->124)	sign-
			+ (PwQzRx - PzQwRx) * E431  		//malformed e2_ goal(e143)	steps(431:->413->143)		sign+

			+ (PwQxRy - PxQwRy) * E412  		//malformed e3_ goal(e124)	steps(412:->142->124) 		sign+
			+ (PzQxRy - PxQzRy) * E312  		//malformed e4_ goal(e132)  steps(312:->132) 			sign-
			+ (PwQzRy - PzQwRy) * E432  		//malformed e1_ goal(e234)  steps(432:->423->243->234) 	sign-

			+ (PxQyRz - PyQxRz) * E123  		//malformed e4_ goal(e132)  steps(123:->)132)			sign-
			+ (PwQxRz - PxQwRz) * E413			//malformed e2_ goal(e143)  steps(413:->143) 			sign-
			+ (PwQyRz - PyQwRz) * E423  		//malformed e1_ goal(e234)  steps(423:->243->234) 		sign+

			+ (PxQyRw - PyQxRw) * E124  		//good, e3_ 
			+ (PyQzRw - PzQyRw) * E234			//good, e1_
			+ (PzQxRw - PxQzRw) * E314  		//malformed e2_ goal(e143)  steps(314:->134->143) 		sign+
		//correct the signs based on shifts above
		P ^ Q ^ R =:
			- (PyQzRx - PzQyRx) * e132
			- (PwQyRx - PyQwRx) * e124  		
			+ (PwQzRx - PzQwRx) * e143
			
			+ (PwQxRy - PxQwRy) * e124
			- (PzQxRy - PxQzRy) * e132  		
			- (PwQzRy - PzQwRy) * e234  		

			- (PxQyRz - PyQxRz) * e132
			- (PwQxRz - PxQwRz) * e143
			+ (PwQyRz - PyQwRz) * e234

			+ (PxQyRw - PyQxRw) * e124
			+ (PyQzRw - PzQyRw) * e234
			+ (PzQxRw - PxQzRw) * e143
		//group by basis
		P ^ Q ^ R =:
			+ (PwQzRx - PzQwRx) * e143
			+ (PzQxRw - PxQzRw) * e143
			- (PwQxRz - PxQwRz) * e143
			
			- (PyQzRx - PzQyRx) * e132
			- (PzQxRy - PxQzRy) * e132  		
			- (PxQyRz - PyQxRz) * e132

			+ (PwQyRz - PyQwRz) * e234
			+ (PyQzRw - PzQyRw) * e234
			- (PwQzRy - PzQwRy) * e234  		

			+ (PwQxRy - PxQwRy) * e124
			- (PwQyRx - PyQwRx) * e124  		
			+ (PxQyRw - PyQxRw) * e124
		//replace notaiton with antivectors
		P ^ Q ^ R =:
			+ (PwQzRx - PzQwRx) * e2_
			+ (PzQxRw - PxQzRw) * e2_
			- (PwQxRz - PxQwRz) * e2_
			
			- (PyQzRx - PzQyRx) * e4_
			- (PzQxRy - PxQzRy) * e4_  		
			- (PxQyRz - PyQxRz) * e4_

			+ (PwQyRz - PyQwRz) * e1_
			+ (PyQzRw - PzQyRw) * e1_
			- (PwQzRy - PzQwRy) * e1_  		

			+ (PwQxRy - PxQwRy) * e3_
			- (PwQyRx - PyQwRx) * e3_  		
			+ (PxQyRw - PyQxRw) * e3_

		//replace Ws with 1
		P ^ Q ^ R =:
			+ (QzRx - PzRx) * e2_
			+ (PzQx - PxQz) * e2_
			- (QxRz - PxRz) * e2_
			
			- (PyQzRx - PzQyRx) * e4_
			- (PzQxRy - PxQzRy) * e4_  		
			- (PxQyRz - PyQxRz) * e4_

			+ (QyRz - PyRz) * e1_
			+ (PyQz - PzQy) * e1_
			- (QzRy - PzRy) * e1_  		

			+ (QxRy - PxRy) * e3_
			- (QyRx - PyRx) * e3_  		
			+ (PxQy - PyQx) * e3_

		//reorder based on antivector 
		//------ POTENTIAL ERROR HERE --------
		//he has N = wedge3d(P,Q), wedge3d(Q,R), wedge3d(R,P);
		// but these do not seem to corresopnd to the coefficient below.
		// Perhaps can be rearrnaged (though this will require distributing negative and separating interior terms).
		P ^ Q ^ R =:
			//no x portion present, this is x component of normal
			+ (QyRz - PyRz) * e1_
			+ (PyQz - PzQy) * e1_
			- (QzRy - PzRy) * e1_  		

			//no y portion present, this is y component of normal
			+ (QzRx - PzRx) * e2_
			+ (PzQx - PxQz) * e2_
			- (QxRz - PxRz) * e2_
			
			//no zcomponent present, this is z component of normal,
			+ (QxRy - PxRy) * e3_
			- (QyRx - PyRx) * e3_  		
			+ (PxQy - PyQx) * e3_

			//all present, this is D, which is -wedge3d(wedge3d(P, Q), R)
			- (PyQzRx - PzQyRx) * e4_
			- (PzQxRy - PxQzRy) * e4_  		
			- (PxQyRz - PyQxRz) * e4_


---------------------------------
PICKUP AT ~ 44:05


		
